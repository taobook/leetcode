# 408. Valid Word Abbreviation | M-18 | v

## **Description**

A string can be **abbreviated** by replacing any number of **non-adjacent**, **non-empty** substrings with their lengths. The lengths **should not** have leading zeros.

For example, a string such as `"substitution"` could be abbreviated as (but not limited to):

*   `"s10n"` (`"s ubstitutio n"`)
*   `"sub4u4"` (`"sub stit u tion"`)
*   `"12"` (`"substitution"`)
*   `"su3i1u2on"` (`"su bst i t u ti on"`)
*   `"substitution"` (no substrings replaced)

The following are **not valid** abbreviations:

*   `"s55n"` (`"s ubsti tutio n"`, the replaced substrings are adjacent)
*   `"s010n"` (has leading zeros)
*   `"s0ubstitution"` (replaces an empty substring)

Given a string `word` and an abbreviation `abbr`, return _whether the string **matches** the given abbreviation_.

A **substring** is a contiguous **non-empty** sequence of characters within a string.

**Example 1:**

**Input:** word = "internationalization", abbr = "i12iz4n" 

**Output:** true 

**Explanation:** The word "internationalization" can be abbreviated as "i12iz4n" ("i nternational iz atio n").

**Example 2:**

**Input:** word = "apple", abbr = "a2e" 

**Output:** false 

**Explanation:** The word "apple" cannot be abbreviated as "a2e".

**Constraints:**

*   `1 <= word.length <= 20`
*   `word` consists of only lowercase English letters.
*   `1 <= abbr.length <= 10`
*   `abbr` consists of lowercase English letters and digits.
*   All the integers in `abbr` will fit in a 32-bit integer.

### Solution
```java
/*
•   "s10n" ("s ubstitutio n")
•   "sub4u4" ("sub stit u tion")
•   "12" ("substitution")
•   "su3i1u2on" ("su bst i t u ti on")
•   "substitution" (no substrings replaced)
思想：先把缩写串中的数字替换成占位符#，然后和原字符串比较
*/
class Solution {
    public boolean validWordAbbreviation(String word, String abbr) {
        //保存全部字符
        StringBuilder sb = new StringBuilder();

        //保存解析出来的数字
        StringBuilder num = new StringBuilder();

        for(int i=0;i<abbr.length();i++){
            char c = abbr.charAt(i);
            //发现非数字表示数字结束，或到最后一个字符
            if (Character.isLetter(c) || i==abbr.length()-1){
                //若是最后一个字符且是数字，追加到num后
                if(i==abbr.length()-1 && Character.isDigit(c)) num.append(c);

                //将数字替换成num个占位符 sub #### u ####
                if(num.length()!=0){
                    int n = Integer.valueOf(num.toString());

                    //提前终止
                    //System.out.println((sb.length()+n)+" vs "+word.length()+", "+n);
                    if(sb.length()+n>word.length()) return false;

                    for(int j=0;j<n;j++) {
                        sb.append("#");
                    }
                    num = new StringBuilder();
                }

                if(Character.isLetter(c)) {//若非字母，那一定是最后一个数字
                    sb.append(c);
                }
            } else {
                //数字以0开始，非法
                if(num.length()==0 && c=='0') return false;
                num.append(c);
            }
        }
        //System.out.println(sb);
        //总长度不合法
        if(word.length()!=sb.length()) return false;

        for(int i=0;i<sb.length();i++){
            char nc = sb.charAt(i);
            if(nc!='#' && nc!=word.charAt(i)) return false;
        }

        return true;
    }
}
```
The code you provided implements a solution to check if a word matches a given abbreviation. The approach is to parse the abbreviation, converting numbers into placeholders (`#`) that represent a sequence of characters, and then comparing the constructed string with the original word.

### Explanation

The main idea of this algorithm is to:
1. Parse the abbreviation (`abbr`) character by character.
2. Whenever a number is found, it is treated as a placeholder for that many characters in the `word`.
3. Replace the number with `#` symbols in a temporary string (`sb`) and then compare it with the `word`.

### Code Walkthrough:

1. **Iterating through the abbreviation**:
    - For each character in `abbr`, if it’s a letter, it's added to the `sb` (StringBuilder). If it’s a number, the number is collected in `num` and eventually processed to generate the appropriate number of `#` symbols (placeholders for characters).
    - The loop also ensures that abbreviations starting with '0' (e.g., "01") are invalid by checking that numbers do not begin with zero.

2. **Building the placeholder string**:
    - Once a full number is encountered, it is converted to that many `#` characters. These placeholders later represent any character in the original `word`.

3. **Validation**:
    - The final placeholder string (`sb`) is then compared with the original `word`. If the lengths differ or any character does not match the word (except for `#`, which is a placeholder for any character), the abbreviation is considered invalid.

4. **Edge cases handled**:
    - Numbers starting with `0` are rejected.
    - The algorithm makes sure the abbreviation's character count (after replacing numbers) doesn't exceed the length of the original word.

### Code Review and Suggestions:

The current code is logically correct and should handle most cases. However, there are a few minor improvements and clarifications that could enhance readability and performance slightly:

1. **Use of `StringBuilder` for `num`**:
    - Instead of creating a new `StringBuilder` for `num` each time, you could reset it with `num.setLength(0);` for slight performance gain.

2. **Handling the last character logic**:
    - Instead of checking `i == abbr.length() - 1` within the loop, it might be more intuitive to handle this logic outside the loop. This makes it clearer and easier to maintain.

3. **Edge case for empty input**:
    - You might want to handle cases where `word` or `abbr` are empty strings explicitly (though it depends on the problem's constraints).

### Revised Code with Minor Optimizations:

```java
class Solution {
    public boolean validWordAbbreviation(String word, String abbr) {
        StringBuilder sb = new StringBuilder(); // to hold the constructed string from abbr
        StringBuilder num = new StringBuilder(); // to collect digits

        for (int i = 0; i < abbr.length(); i++) {
            char c = abbr.charAt(i);

            // If we encounter a letter or the last character (which could be a digit), process the current number
            if (Character.isLetter(c) || i == abbr.length() - 1) {
                // If last character is a digit, append it to num
                if (i == abbr.length() - 1 && Character.isDigit(c)) num.append(c);

                // Convert num to a number and add placeholders ('#') if necessary
                if (num.length() != 0) {
                    int n = Integer.valueOf(num.toString());

                    // Early termination if the constructed string would exceed the word's length
                    if (sb.length() + n > word.length()) return false;

                    // Append '#' placeholders
                    for (int j = 0; j < n; j++) {
                        sb.append("#");
                    }
                    num.setLength(0); // Reset the num builder
                }

                // If it's a letter, add it to the constructed string
                if (Character.isLetter(c)) {
                    sb.append(c);
                }
            } else {
                // Append digits to num, check for leading zero
                if (num.length() == 0 && c == '0') return false; // Leading zeros are invalid
                num.append(c);
            }
        }

        // Final length check
        if (word.length() != sb.length()) return false;

        // Compare the constructed string with the original word
        for (int i = 0; i < sb.length(); i++) {
            char nc = sb.charAt(i);
            if (nc != '#' && nc != word.charAt(i)) return false;
        }

        return true;
    }
}
```

### Complexity Analysis:

- **Time Complexity**: \(O(n + m)\), where `n` is the length of the abbreviation and `m` is the length of the word. Each character in both the abbreviation and the word is processed once.
- **Space Complexity**: \(O(n)\), where `n` is the length of the abbreviation because of the use of the `StringBuilder` to construct the processed abbreviation string.

### Conclusion:

This implementation is efficient and ensures the correct handling of the abbreviation format by checking against the rules (e.g., no leading zeros, valid lengths, etc.). The improvements focus on simplifying and making the code more efficient in terms of resetting `StringBuilder` and handling certain logic more clearly.